Фільтр за територіями
=====================

Тут пояснюється, як отримати дані для якоїсь поіменованої території, наприклад міста чи громади.

<a name="deprecation"/>
## Попередження про припинення підтримки

У цьому посібнику стверджується,
що його зміст залишається чинним протягом багатьох років.
Це не обов’язково стосується поточної моделі _area_.
Цей тип даних було створено, щоб бути сумісним у випадку його появи в OpenStreetMap.
У автора є сумніви, що він колись там з'явиться.

Тож, зараз є плани зосередитись над наявними типами _closed way_ та _closed relation_,
що по суті представлено як _multipolygon_.
Реалізація може зайняти кілька років,
і в кінцевому підсумку деякі з перерахованих тут варіантів синтаксису стануть застарілими.
За для підтримання [зворотньої сумісності](../preface/assertions.md#infrastructure),
не всі варіанти синтаксису будуть вилучені.

Починаючи з версії 0.7.57, _лінії_ вже зазнали змін,
але _зв'язки_ залишаються зі згенерованими типом даних.

Вираз `is_in` та запити з типом `area` зараз повертають замкнені лінії
та полігони, що утворюються зі _зв'язків_.
І навпаки, критерій `area` аналізує як замкнені лінії, так і згенеровані полігони.
Критерій `(pivot)` та вираз `map_to_area` пропускають  замкнені _лінії_
без змін, і лише виконують перетворення між _зв'язками_ та полігонами, створеними з них.

Конкретних планів щодо роботи по переробці _зв'язків_ немає.
У проєкті ще є багато нагальних питань,
тому ці зміни можуть відбутись не скоро.

<a name="per_tag"/>
## Назви чи Теґи

Типовим варіантом використання областей в Overpass API є завантаження 
всіх об’єктів певного типу або всіх об’єктів загалом у потрібній області 
інтересу.
Почнемо з об'єктів досить розрідженого типу,
всі види об'єктів – це занадто багато даних
щоб отримати швидкі відповіді на запити з таким синтаксисом.
Після того, як механізм _area_ буде пояснений у цьому розділі, докладніше
про завантаження всіх об'єктів буде в [наступному підрозділі](#full).

Для початку, ми знайдемо [всі супермаркети в Лондоні](https://overpass-turbo.eu/?lat=30.0&lon=0.0&zoom=2&Q=CGI_STUB):

    area[name="London"];
    nwr[shop=supermarket](area);
    out center;

Насправді вся робота з пошуку відбувається у рядку 2,
_фільтр_ `(area)` обмежує обсяг потрібних об'єктів тими, що повністю
або частково знаходяться в поіменованому полігоні змінної `_`.
Тож для початку ми маємо помістити нашу область інтересу у змінну `_`.

Рядок 1 шукає всі об'єкти типу _area_
з ключем `name` та значенням `London`.
Пояснення для цього об'єкта дивіться [далі](#background).
До речі, весь вираз все ще є виразом [_query_](../preface/design.md#statements).

Несподівано ми отримуємо багато результатів з половини планети.
Це тому, що у світі багато місць, які називаються `London`;
нам потрібно зазначити, що нам потрібен Лондон в Англії.
Є п’ять різних способів зробити наш запит більш точним.

Ми можемо зазначити величезний обмежувальний прямокутник, що містить нашу
область інтересу та спробувати такий [запит](https://overpass-turbo.eu/?lat=30.0&lon=0.0&zoom=2&Q=CGI_STUB):

    area[name="London"];
    nwr[shop=supermarket](area)(50.5,-1,52.5,1);
    out center;

Зауважте, що координати обмежувального прямокутника можуть бути
[отримані автоматично](https://overpass-turbo.eu/?lat=51.5&lon=-0.1&zoom=10&Q=CGI_STUB) за допомогою використання [зручностей](../targets/turbo.md#convenience) _Overpass Turbo_:

    area[name="London"];
    nwr[shop=supermarket](area)({{bbox}});
    out center;

В обох випадках, обмежувальний прямокутник працює як фільтр в парі з фільтром `(area)`.
Через те що фільтр `(area)` є тимчасовою імплементацією, для нього ніколи не додавалась можливість зазначати координати обмежувального прямокутника.
Але це добре виправляється показаним вище спосіб, тож це також вплинуло на низький пріоритет для реалізації цієї функції.

Подібним чином ми можемо скористатися тим, що Лондон знаходиться у Великобританії.
В одному з [наступних підрозділів](#combining) буде показано як таке зробити.

І останнє, але не менш важливе, ми можемо взяти до уваги інші теґи
щоб розрізняти декілька _area_ з однаковим теґом _name_.
У випадку з Лондоном [може згодитись](https://overpass-turbo.eu/?lat=30.0&lon=0.0&zoom=2&Q=CGI_STUB) теґ _wikipedia_:

    area[name="London"]["wikipedia"="en:London"];
    nwr[shop=supermarket](area);
    out center;

Так само, як і перший фільтр `[name="London"]`,
наступний фільтр застосовується у першому рядку запиту.
Таким чином у нас залишається тільки один об'єкт _area_, який ми й
шукали.

Іншим доволі корисним теґом може бути теґ `admin_level` разом або без
додаткового теґу `type=boundary`.
Тут може допомогти, спочатку, [показ](https://overpass-turbo.eu/?lat=51.5&lon=-0.1&zoom=10&Q=CGI_STUB) та докладне вивчення об'єктів _area_;
для цього після `Run` перейдіть на вкладку `Data` у верхньому куті праворуч:

    area[name="London"];
    out;

Рядок 2 виводить результати пошук з рядка 1.
Відшукайте ті _теґи_ та їх комбінації, що є унікальними для області інтересу.
А використовуючи фільтр _pivot_,
у вас є змога їх [візуалізувати](https://overpass-turbo.eu/?lat=30.0&lon=0.0&zoom=2&Q=CGI_STUB):

    area[name="London"];
    nwr(pivot);
    out geom;

Рядок 2 містить звичайний вираз _query_.
Фільтр `(pivot)` тут вибирає саме ті об'єкти, 
які згенеровано на виході генератора _area_.
Вони знаходяться у змінній `_`.

П'ята можливість - це зручна функція [Overpass Turbo](../targets/turbo.md)
як [дозволяє обрати](https://overpass-turbo.eu/?lat=51.5&lon=-0.1&zoom=10&Q=CGI_STUB) _Nominatim_ для пошуку потрібної області інтересу:

    {{geocodeArea:London}};
    nwr[shop=supermarket](area);
    out center;

Вираз `{{geocodeArea:London}}` перенаправляє запит
з _Overpass Turbo_ до _Nominatim_ для пошуку найбільш відповідних об'єктів з назвою `London`.
Скориставшись ідентифікатором об'єктів з Nominatim,
Overpass Turbo робить його підстановку в запит,
наприклад `area(3600065606)`.

<a name="full"/>
## Всі дані

Тепер ми хочемо завантажити дійсно всі дані в області інтересу.
Це працює майже так само із запитом, який ми використовували [як навчальний](#per_tag).
Але нам потрібно змінити інструмент:
Для області розміром з Лондон можна легко подолати поріг у 10 мільйонів об'єктів,
в той час як _Overpass Turbo_ вже з 2000 об'єктів суттєво уповільнює роботу оглядача.

Крім того, практично для всіх територій в офіційних межах пропонується  використовувати регіональні вибірки.
Подробиці про це в [підрозділі про регіональні вибірки](other_sources.md#regional).

В обох випадках ви можете завантажити необроблені дані безпосередньо на ваш комп'ютер:
Для цього _Overpass Turbo_ пропонує в меню _Експорт_  `завантаженя сирцевих даних OSM`.
Це нормально, що відразу після клацання нічого не відбувається.
Завантаження всього Лондона може зайняти кілька хвилин.

Може бути простішим використовувати такі інструменти для завантаження, як [Wget](https://www.gnu.org/software/wget/) або [Curl](https://curl.haxx.se/).
Щоб зробити це, будь ласка, збережіть один із запитів зверху в локальному файлі, напр. `london.ql`.

Потім ви можете виконувати запити в командному рядку за допомогою
<!-- NO_QL_LINK -->

    wget -O london.osm.gz --header='Accept-Encoding: gzip, deflate' \\
        --post-file=london.ql 'https://overpass-api.de/api/interpreter'

або
<!-- NO_QL_LINK -->

    curl -H'Accept-Encoding: gzip, deflate' -d@- \\
        'https://overpass-api.de/api/interpreter' \\
        <london.ql >london.osm.gz

Обидві команди, звичайно, можна написати без зворотної косої риски в один рядок.
В обох випадках ви зробите всім велику послугу
якщо ви встановите додатковий заголовок `Accept-Encoding: gzip, deflate`.
Це дає серверу право стискати дані,
і це зменшує обсяг даних приблизно в сім разів і розвантажує обидва кінці з'єднання.

Тепер переходимо до самого запиту.
Оскільки джерелом великої кількості некорисних даних є великі зв'язки,
існує кілька варіантів [адаптованих до кожного варіанту подальшого використання](osm_types.md).
Обмежимось тут добре адаптованим варіантом:
<!-- NO_QL_LINK -->

    area[name="London"]["wikipedia"="en:London"];
    (
      nwr(area);
      node(w);
    );
    out;

Як альтернатива, варіант
що демонструє використання фільтра `(area)` кілька разів.
В цьому випадку ми [зберігаємо](../preface/design.md#sets) обрану область інтересу в іменованій _змінній_:
<!-- NO_QL_LINK -->

    area[name="London"]["wikipedia"="en:London"]->.area_of_interest;
    (
      node(area.area_of_interest);
      way(area.area_of_interest);
      node(w);
    );
    out;

Тут оператор запиту в рядку 3 записує свій результат у типову змінну `_`.
Оскільки область інтересу нам буде потрібна в рядку 4, її потрібно 
зберегти в іншому місці ніж типовий вивід, в цьому випадку `area_of_interest`.

<a name="combining"/>
## Область в середині області

Повернемось до завдання
вибрати Лондон у Великій Британії.
Це не можна зробити безпосередньо,
але знову є два рішення.

Перше, ви можете шукати об'єкти,
які знаходяться [на перетині двох областей інтересу](https://overpass-turbo.eu/?lat=51.5&lon=-0.1&zoom=8&Q=CGI_STUB):

    area[name="London"]->.small;
    area[name="England"]->.big;
    nwr[shop=supermarket](area.small)(area.big);
    out center;

Безпосередній відбір відбувається у рядку 3;
тут знаходяться об'єкти які відповідають всім трьом умовам.
Супермаркети – фільтр `[shop=supermarket]`.
Фільтр `(area.small)` вибирає об'єкти, які знаходяться в одній з малих областей, змінна `.small`.
А фільтр `(area.big)` вибирає об'єкти, які попадають в більшу область, змінна `big`.

Ми маємо бути впевнені, що змінні `small` та `big` містять потрібні ділянки.
Це зазначається запитами для _областей_ у рядках 1 та 2,
які зберігають значення у власних іменованих змінних.

Інший підхід використовує зв’язок між _area_ та створеним об'єктом, 
але на цей раз у напрямку, протилежному ефекту фільтра _pivot_.
Ми [обираємо](https://overpass-turbo.eu/?lat=51.5&lon=-0.1&zoom=8&Q=CGI_STUB) створений об'єкт для меншої області:

    area[name="England"];
    rel[name="London"](area);
    map_to_area;
    nwr[shop=supermarket](area);
    out center;

В рядку 4, ми використовуємо фільтр `(area)` для фільтрації саме по території Лондона.
Для цього ми знайшли всі _зв'язки_ з назвою _London_ в рядку 2, які
знаходяться в області заданій фільтром `(area)`, що зберігається в типовій змінній `_`.
Всі області з назвою _England_ перед цим були записані до типової змінної у рядку 1.

Тепер нам потрібні області в рядку 4, 
хоча фільтр `(area)` не може фільтрувати області, тому ми вдалися до вибору _зв'язків_ замість цього.
Далі скористаємось `map_to_area`, щоб перетворити об'єкти у типовій змінні на області.

<a name="background"/>
## Технічні подробиці
<!-- Not yet checked -->

Від початку проєкту Overpass API у 2009 р.
можливість перевіряти наявність A-є-в-Б була метою проєкту.
Але це цілком суперечить вимогам [правдивого представлення](../preface/assertions.md#faithful) даних OpenStreetMap.
Області в OpenStreetMap є концепцією, яка поєднує теґи та геометрію, і були впевнені спроби мати явний тип даних _area_.
На той час ще не були встановлені правила, що саме є областю.
Не в останню чергу мапери побоювалися, що області можуть пошкоджуватися досить часто.

З цієї причини _area_ є явним типом даних в Overpass API.
Сервер генерує їх у фоновому режимі за допомогою [схеми](https://github.com/drolbr/Overpass-API/tree/master/src/rules), яка відокремлена від сирцевого коду.
Таким чином, оператори незалежних запитів легше можуть вирішити, які області вони насправді хочуть створити.
Кожна _область_ отримує теґи від об'єктів, з яких вона створюється.

Це має певні наслідки:

* Області з'являються на кілька годин пізніше, ніж об'єкти з яких вони створюються.
  Відповідно, зміни в об'єктах, з яких створено області, впливають на зміни області із затримкою.
* Якщо об'єкт більше не є геометрично правильною областю, то старий об'єкт _area_ залишається незмінним, доки з об'єкта, на основі якого була створена область, не можна буде створити нову область.
* Області мають власні правила, як поширюються їхні ідентифікатори.
* Лише частину фільтрів, які можна використовувати для об'єктів OpenStreetMap, також можна використовувати для _area_.

Але велика перевага полягає в тому, що пошук точки в області працює надійно та ефективно.

Іноді виявляється, що не всі об'єкти з яких було створено область, залишаються існувати. Зараз, майже будь-який об'єкт, геометрія якого підходить для створення області, семантично є областю.
Але якщо фоновий процес не вважає, що згенерований об'єкт утворює область відповідно до своїх теґів, то відповідна область не створюється.

Однак, за роки існування проєкту автор не знайшов жодного випадку, який би реалізував правила створення областей для практичного використання.
Був скоріше компроміс, що менше буде областей то менше процесорного часу буде витрачатись на їх створення.
Таким чином, схема правил де-факто централізована, і це зводить нанівець більшість переваг підходу.

З цієї причини автор тим часом також має намір виконувати операції з областями безпосередньо над необробленими об'єктами OpenStreetMap.
Для ліній такий підхід був реалізований починаючи з версії 0.7.57.
