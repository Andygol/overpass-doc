Геометрія
=========

Щоб пояснити різні варіанти отримання повних даних OpenStreetMap в межах регіону
тут треба пояснити тонкощі моделі даних OpenStreetMap.

<a name="scope"/>
## Область застосування

Типи даних OpenStreetMap вже були представлені у [підрозділі](../preface/osm_data_model.md) вступу.
Тож ви вже знаєте про точки, лінії та зв'язки.

Дані OpenStreetMap можна представити різними способами.
Про вихідні формати, такі як JSON чи XML, йдеться у відповідному підрозділі розділу [Формати даних](../targets/formats.md).
Про перелік можливих рівнів деталізації, що стосуються структури, геометрії, теґів, версій та атрибутів ви можете дізнатись тут.

Тут йдеться про те, як доповнити лінії та зв'язки інформацією про їх геометрію,
так, щоб обсяг отриманих даних залишався прийнятним.

<a name="nodes_ways"/>
## Лінії та точки

Придатну для використання геометрію для точок отримати легко:
Всі види виводу, крім `out ids` та `out tags`, включають інформацію про координати точок,
через те що координати і так є частиною даних точок, відповідно до моделі даних OpenStreetMap.

На відміну від точок, лінії отримують інформацію про власну геометрію у різний спосіб:
У кращому випадку ваша програма може працювати з координатами ліній.

Ви можете помітити різницю, напр. в Overpass Turbo,
порівнявши результати двох наступних запитів на вкладці _Data_ (верхній правий кут):
[без координат](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    way(51.477,-0.001,51.478,0.001);
    out;


та [з координатами](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    way(51.477,-0.001,51.478,0.001);
    out geom;

Оригінальна модель даних OpenStreetMap не передбачає наявність координат для ліній,
через те що вони вже є у точок з яких складається лінія.
Тому все ще існують програми, які не можуть обробляти координати ліній.
Для них існує два варіанти, щоб передати геометрію традиційним способом.

З найменшими зусиллями, якщо запитуються координати тільки для точок.
Або після виводу ліній, за допомогою оператора `node(w)` отримати всі точки, на які посилаються лінії;
режим `out skel` зменшує обсяг даних до чистих координат, та 
застосування `qt` зменшує потребу в сортуванні отриманих даних:
[(запит)](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    way(51.477,-0.001,51.478,0.001);
    out qt;
    node(w);
    out skel qt;

Подивіться на отримані дані на вкладці _Data_ (верхній кут праворуч).
Точки будуть йти відразу після ліній.

Це вже ближче до вихідної моделі даних,
але є програми, які досі не працюють з цією формою даних.
Взагалі то, заведено розміщувати всі точки перед лініями і сортувати елементи одного типу за їх ідентифікаторами.
Для цього нам потрібно завантажувати точки і лінії паралельно перед тим як вивести будь-що.
Вираз `(._; node(w););` досягає цього за допомоги трьох виразів `._`, `node(w)` та `(…)`:
[(запит)](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    way(51.477,-0.001,51.478,0.001);
    (._; node(w););
    out;

Точки та лінії, кожна із всіма їх власними деталями, пояснюються [в останньому розділі](#full).

<a name="rels"/>
## Зв'язки

Так само як і у випадку з лініями, найпростішим буде отримання геометрії за допомогою вбудованих можливостей Overpass API.
Порівняйте два запити:
[без координат ](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    relation(51.477,-0.001,51.478,0.001);
    out;

та [з координатами](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    relation(51.477,-0.001,51.478,0.001);
    out geom;

На відміну від ліній дані завантажуються в порядку їх важливості:
У запиті без координат ми бачимо лише ідентифікатори ліній, 
але ж фактично, кожна лінія складається з багатьох точок, які, відповідно, мають координати.

Зв'язки, членами яких є лінії, є найпоширенішими.
Тому був розроблений механізм, який дозволяє обмежити вивід геометрії межами обмежувального прямокутника,
про це можна дізнатись з розділу [Обрізання виводу](bbox.md#crop):
[приклад](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    relation(51.477,-0.001,51.478,0.001);
    out geom({{bbox}});

Оригінальна модель даних OpenStreetMap не передбачає наявність координат для зв'язків, також.
Для програмного забезпечення, яке строго слідує оригінальній моделі даних, знов таки ж,
є два варіанти отримання даних.
Отримуються результати максимально скорочені до координат для зв'язків,
отримавши самі зв'язки з подальшим розв'язанням їх залежностей.
Це потребує двох потоків обробки даних,
тому що зв'язки можуть безпосередньо отримати координати для точок, які самі є членами зв'язків,
а також їм потрібні координати точок для членів-ліній.
Для цього ми використаємо чотири вирази.
Через те, що це досить частий випадок, тут використовується досить коротке скорочення `>`:
[(приклад)](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    relation(51.477,-0.001,51.478,0.001);
    out qt;
    >;
    out skel qt;

У порівнянні з попереднім виводом обсяг даних уже подвоївся,
тому що ми завжди повинні включати як референсні дані, так і залежності для них.

Повністю сумісний варіант вимагає ще більшого обсягу даних.
Тут використовується вираз `(._; >;);` зібраний з виразів `._`, `>` та `(…)`:
[(приклад)](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    relation(51.477,-0.001,51.478,0.001);
    (._; >;);
    out;

Чи існує рішення щодо обмеження виводу обмежувальним прямокутником?
Оскільки зв'язок може знаходитись в обмежувальному прямокутнику, якщо
хоча б один з його членів знаходиться в прямокутнику,
ми можемо досягти цього спочатку отримуючи об'єкти з обмежувального прямокутника,
з подальшим розв'язанням зворотніх залежностей.
Вираз `<` як раз допомагає в цьому.
Це скорочення, яке використовується для пошуку всіх ліній та зв'язків
які складаються з отриманих точок та ліній, відповідно.
Тож ми шукаємо всі точки та лінії в обмежувальному прямокутнику.
Ми зберігаємо їх у виразі `._` і шукаємо всі зв'язки, що посилаються на них
як на своїх членів: [(приклад)](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    ( node(51.477,-0.001,51.478,0.001);
      way(51.477,-0.001,51.478,0.001); );
    (._; <;);
    out;

Зв'язки можна помітити по слідах, які вони залишають на своїх членах.
Вони мають інший колір на відміну від звичайних результатів в Overpass Turbo.
Зв'язки досить просто знайти на вкладці _Data_;
прокрутіть в кінець.

Отже, більшість членів відносин взагалі не завантажені;
завантажуються лише елементи в межах обмежувального прямокутника.
Запит все ще не готовий для використання, оскільки ми не завантажили всі потрібні точки для ліній.
Повний запит знаходиться наприкінці в розділі [Підсумки](#full).

<a name="rels_on_rels"/>
## Зв'язки, що складаються зі зв'язків

Для демонстрації проблеми отримання зв'язків, що складаються зі зв'язків
нам доведеться збільшити розмір обмежувального прямокутника.
Розпочнемо спочатку із запиту основного зв'язку:
[(посилання)](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    relation(51.47,-0.01,51.48,0.01);
    (._; >;);
    out;

Тепер замінимо підстановку членів зв'язка

* зворотню підстановку для членів-зв'язків
* пряму підстановку для членів вкладених зв'язків, для отримання координат

Такі підстановки виконуються за допомогою виразів `rel(br)` та `>>`:
[(посилання)](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    relation(51.47,-0.01,51.48,0.01);
    ( rel(br); >>;);
    out;

В залежності від системи звідки ви виконуєте такий запит,
він може паралізувати роботу вашого оглядача або спровокувати появу попередження про це.
Ми хочемо отримати куточок передмістя Гринвіча,
а насправді отримуємо дані майже для всього Лондона,
через наявність збірки зв'язків з назвою _Quietways_.
Що призводить до багатократного збільшення і таке не малого обсягу уданих.

Навіть якщо ви не зустрінетесь зі зв'язками-колекціями в майбутньому, 
як в нашому прикладі, чи справді ви бажаєте наражати ваш застосунок
отриманням непередбачуваної кількості даних, тільки через те, що
хтось з маперів створив зв'язок-колекцію, що містить кілька зв'язків?

Через це з боку розробників Overpas API є стійке заперечення таких зв'язків.
На їх думку, такі структури в даних створюють ризик отримання непередбачуваної кількості даних.

Якщо у вас дійсно є потреба в обробці зв'язків, що складаються з інших 
зв'язків, то для цього є дієве рішення - обмежитись лише такими зв'язками без спроби виконати пряму підстановку.
Для цього змінимо останній запит з отримання _зв'язків_ на початку, до їх зворотньої реконструкції за отриманими перед цим об'єктами `rel(br)`:
[(посилання)](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    ( node(51.47,-0.01,51.48,0.01);
      way(51.47,-0.01,51.48,0.01); );
    (._; <; rel(br); );
    out;

<a name="full"/>
## Підсумки

Ми розглянули тут найбільш вірогідні корисні варіанти.

Якщо обране вами програмне забезпечення може обробляти координати об’єкта,
тоді ви можете отримати всі точки, лінії та зв'язки всередині обмежувального прямокутника:
[(посилання)](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    ( node(51.477,-0.001,51.478,0.001);
      way(51.477,-0.001,51.478,0.001); );
    out geom qt;
    <;
    out qt;

Цей запит збирає

* всі точки в середині прямокутника (запит - рядок 1, вивід - рядок 3)
* всі лінії в середині прямокутника, включаючи ті, що перетинають прямокутник, але не мають власних точок в ньому (запит - рядок 2, вивід - рядок 3)
* всі зв'язки, які мають принаймні одну точку чи лінію в середині прямокутника (запит - рядок 4, вивід - рядок 5); зв'язки не отримують іншої геометрії крім геометрії наявних членів.

Ви отримуєте ті самі дані без зв’язків, якщо використовуєте лише рядки з 1 по 3.

Ви отримаєте зв'язки, які складаються зі зв'язків, якщо зміните рядок 4:
[(посилання)](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    ( node(51.47,-0.01,51.48,0.01);
      way(51.47,-0.01,51.48,0.01); );
    out geom qt;
    ( <; rel(br); );
    out qt;

Ви також можете виводити дані в традиційному форматі, відсортовані за типом елемента з неявним зазначенням отримання геометрії.
Це вимагає, зокрема, прямого розв'язання геометрії ліній, через отримання координат їх точок.
Для цих потреб потрібно замінити вираз `<` точнішою ідіомою,
бо у зворотньому випадку вираз `<` підхватить лінії для тільки що доданих точок.
Перший варіант виглядає наступним чином:
[(посилання)](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    ( node(51.47,-0.01,51.48,0.01);
      way(51.47,-0.01,51.48,0.01); );
    ( ._;
      (
        rel(bn)->.a;
        rel(bw)->.a;
      ); );
    ( ._;
      node(w); );
    out;

Тут рядки з 3 по 7 відповідають за зв'язки.
Без рядків з 4 по 8, але з рядками з 9 по 11, що використовуються для
доповнення ліній на виході будуть лише точки та лінії.

І навпаки, зв'язки що складаються зі зв'язків можна зібрати
шляхом додавання додаткового рядка 8 до наявного рядка 7:
[(посилання)](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=CGI_STUB)

    ( node(51.47,-0.01,51.48,0.01);
      way(51.47,-0.01,51.48,0.01); );
    ( ._;
      (
        rel(bn)->.a;
        rel(bw)->.a;
      );
      rel(br); );
    ( ._;
      node(w); );
    out;

Існують інші підходи,
але вони мають переважно історичне значення.
Два з них буде розглянуто в [наступному підрозділі](map_apis.md).
