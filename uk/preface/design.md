Модель роботи
=============

За якими правилами Overpass API обробляє запити?
Кожен блок запиту дає уявлення
як ці елементи складаються в робочий запит.

<a name="sequential"/>
## Послідовне виконання

Більшість складних варіантів використання запитів вимагає вибору елементів з попередніх результатів.
Гарним прикладом буде супермаркет, який знаходиться поруч із залізничною станцією.
Супермаркет пов'язаний із залізницею лише тим, що вони знаходяться поруч один поруч з іншою.

Відповідно до побудови структури речення
ми спочатку шукаємо супермаркет
потім, ми залишаємо супермаркет в результатах пошуку для яких ми знаходимо станцію поблизу.
Такий підхід, з використанням звичайної мови, швидко приводить нас до каламуті відносних речень,
і в формальній мові запитів це дратує не менш.

Тому мова запитів Overpass API дотримується покрокової парадигми,
та званого _імперативного програмування_.
В кожен момент часу виконується тільки одне просте завдання,
а складні завдання вирішуються шляхом складання в чергу кількох простих завдань.
Це підводить нас до наступного підходу:

* Вибір всіх станцій в зоні нашого інтересу (регіоні).
* Заміна попереднього результату на супермаркети, які знаходяться поруч з об'єктами з попереднього кроку.
* Вивід переліку знайдених супермаркетів.

Ці інструкції можна записати у вигляді наступного запиту.
Ви можете [виконати](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=13&Q=nwr%5Bpublic_transport%3Dstation%5D%28%7B%7Bbbox%7D%7D%29%3B%0Anwr%5Bshop%3Dsupermarket%5D%28around%3A100%29%3B%0Aout%20center%3B) його зараз:

    nwr[public_transport=station]({{bbox}});
    nwr[shop=supermarket](around:100);
    out center;

Пояснення синтаксису ви знайдете далі.

В простому випадку вам згодиться спрощений синтаксис,
але отримане дворядкове рішення показує чітке розділення обов'язків:

    nwr[shop=supermarket]({{bbox}});
    out center;

* Вираз в першому рядку говорить _що_ ми хочемо знайти
* Наступний вираз говорить про те _як_ ми хочемо отримати результат. Докладніше про це дивіться в розділі [Формати](../targets/formats.md#faithful)

<a name="statements"/>
## Інструкції та фільтри

Порівняємо запити де ми тільки отримуємо супермаркети з видимої частини мапи

    nwr[shop=supermarket]({{bbox}});
    out center;

із попереднім вище

    nwr[public_transport=station]({{bbox}});
    nwr[shop=supermarket](around:100);
    out center;

для визначення компонентів.

Найважливіший символ - крапка з комою;
кожен вираз закінчується саме крапкою з комою.
Натомість пробіли (перенесення рядків, відступи та інше) для всього синтаксису не мають значення.
Вирази виконуються один за одним у тому порядку, в якому вони зазначені в тексті запиту.
В обох запитах маємо чотири вирази разом:

* ``nwr[shop=supermarket]({{bbox}});``
* ``nwr[public_transport=station]({{bbox}});``
* ``nwr[shop=supermarket](around:100);``
* ``out center;``

Вираз ``out center`` відповідає за вивід та немає додаткових субструктур.
Можливості керування виводом описані в розділі [Формати](../targets/formats.md).

Всі інші вирази є _запитами_, тобто вони кажуть які об'єкти потрібні.
Це стосується всіх виразів що починаються з ``nwr`` та наступних ключових слів.  
Слова ``node``, ``way`` та ``relation`` призначені для отримання об'єктів відповідних типів,
``nwr`` (скорочення від _nodes_, _ways_, _relations_) включає об'єкти всіх типів в результат.
Вираз _запит_ має субструктури, які з'являються кілька разів:

* ``[shop=supermarket]`` and ``[public_transport=station]``
* ``({{bbox}})``
* ``(around:100)``

Всі субструктури виразу _запит_ обмежують те які об'єкти будуть знайдені.
Тож, вони називаються _фільтри_.
Ви можете використовувати разом будь-яку кількість фільтрів в одному виразі.
_Запит_ буде шукати саме ті об'єкти, які відповідають умовам всіх фільтрів.
Порядок фільтрів не важливий, бо з технічного боку вони накладаються паралельно.

В той час як ``[shop=supermarket]`` та ``[public_transport=station]`` містять всі об'єкти,
які мають відповідні теґи (в одному випадку - супермаркети, в іншому залізничні станції),
фільтри ``({{bbox}})`` та ``(around:100)`` відбирають об'єкти за просторовими характеристиками.

Фільтр ``({{bbox}})`` дозволяє обрати всі об'єкти,
які повністю або частково знаходяться в зазначеній області.

Складніше працює фільтр ``(around:100)``.
Для роботи йому потрібні вхідні значення, значення отримані в попередньому запиті.
Він шукає всі об'єкти які знаходяться від отриманих раніше об'єктів на відстані не більше 100 метрів.

З цього місця починає працювати парадигма поетапної обробки запитів:
Фільтр ``(around:100)`` отримує результати у вигляді вхідних даних про залізничні станції,
які було знайдено при обробці попереднього виразу.

<a name="block_statements"/>
## Блокові вирази

Як поєднати два вирази з допомогою умови OR?
[В такий спосіб](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=14&Q=%28%0A%20%20nwr%5Bpublic%5Ftransport%3Dstation%5D%28%7B%7Bbbox%7D%7D%29%3B%0A%20%20nwr%5Bshop%3Dsupermarket%5D%28%7B%7Bbbox%7D%7D%29%3B%0A%29%3B%0Aout%20center%3B) один вираз шукає всі об'єкти які є супермаркетами, а інший залізничні станції:

    (
      nwr[public_transport=station]({{bbox}});
      nwr[shop=supermarket]({{bbox}});
    );
    out center;

Тут два вирази _query_ складають блок у більшій структурі.
Тому, структура взята у дужки називається _блоковим виразом_.

Така блокова структура називається _union_
та використовується для поєднання кількох виразів. Ця структура
отримує всі об'єкти, які запитуються будь-яким виразом з блоку.
В блоці має бути принаймні один вираз, кількість виразів в блоці може бути довільною.

Крім цього існують й інші блокові вирази:

* Блокова структура _difference_ дозволяє прибрати результат одного запиту з результатів іншого запита.
* _if_ виконує блок тільки за умови виконання умови в виконання умови в заголовку блоку _if_.
  Також, на додачу до виразу, що виконується за виконання основної умови може бути блок, який виконується якщо основна умова отримує значення false, тобто вона не виконується.
* _foreach_ виконує свій блок для кожного з його елементів, які отримуються на вході.
* _for_ спочатку об'єднує об'єкти в групи, потім виконує власний блок для кожної групи.
* _complete_ використовується замість циклу _while_.
* Інші блокові вирази використовуються для отримання вилучених об'єктів чи колишніх версій об'єктів.

<a name="evaluators"/>
## Елементи Evaluator та Derived

Ми поки що не розглянули як 
зазначати умови для блокових виразів _if_ або _for_.

Механізм, який використовується для цього, також корисний для інших завдань.
Ви можете, наприклад, створити [перелік назв вулиць](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=%5Bout%3Acsv%28name%29%5D%3B%0Away%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Beispiel%20name%3D%5F%2Eval%3B%0A%20%20out%3B%0A%7D) в певному місці.

    [out:csv(name)];
    way[highway]({{bbox}});
    for (t["name"])
    {
      make Beispiel name=_.val;
      out;
    }

Рядки 2 та 6 містять прості вирази ``way[highway]({{bbox}})`` та ``out`` відповідно.
``[out:csv(name)]`` в рядку 1 визначає формат виводу ([див тут](../targets/index.md)).
Рядки 3, 4, та 7 утворюють блоковий вираз ``for (t["name"])``;
потрібно знати за якими критеріями відбувається групування елементів.

_Evaluator_ ``t["name"]`` відповідає за вибір критеріїв.
_Evaluator_ - це вираз
який оцінюється в контексті виконання оператора.

Цей конкретний _evaluator_ є виразом, який застосовується один раз для кожного обраного об'єкта, 
тому що для _for_ потрібен один результат для кожного обраного об'єкта.
Вираз ``t["name"]`` оцінює наявність теґу з ключем _name_ в об'єкта.
Якщо об'єкт не має теґа з ключем _name_
вираз повертає порожній рядок.

Рядок 5 містить _evaluator_ ``_.val``.
Його завдання додавати значення, яке треба повернути.
Оператор _make_ завжди створює один об'єкт з потенційно багатьох об'єктів.
Отже, значення ``_.val`` не може залежати від окремих об'єктів.
Цей спеціальний вираз ``_.val`` надає значення об'єктам в залежності від виконання виразу у циклі _for_.
В цьому випадку, значення теґу _name_ для всіх об'єктів в циклі.

Якщо очікується незалежне від об'єкта значення, але надається об'єктно-залежний вираз, 
то створюється повідомлення про помилку.
Це відбувається, наприклад, якщо ми хочемо обчислити довжину всіх вулиць:
[Спробуйте](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=%5Bout%3Acsv%28length%2Cname%29%5D%3B%0Away%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Beispiel%20name%3D%5F%2Eval%2Clength%3Dlength%28%29%3B%0A%20%20out%3B%0A%7D)!

    [out:csv(length,name)];
    way[highway]({{bbox}});
    for (t["name"])
    {
      make Beispiel name=_.val,length=length();
      out;
    }

Кілька відрізків однойменної вулиці можуть мати різну довжину.
Це можна виправити, надавши вказівки, яким чином потрібно об'єднати об'єкти.
Як правило у більшості випадків потрібен [перелік](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=%5Bout%3Acsv%28length%2Cname%29%5D%3B%0Away%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Beispiel%20name%3D%5F%2Eval%2Clength%3Dset%28length%28%29%29%3B%0A%20%20out%3B%0A%7D):

    [out:csv(length,name)];
    way[highway]({{bbox}});
    for (t["name"])
    {
      make Beispiel name=_.val,length=set(length());
      out;
    }

Але в цьому конкретному випадку брати суму [більше доречно](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=%5Bout%3Acsv%28length%2Cname%29%5D%3B%0Away%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Beispiel%20name%3D%5F%2Eval%2Clength%3Dsum%28length%28%29%29%3B%0A%20%20out%3B%0A%7D):

    [out:csv(length,name)];
    way[highway]({{bbox}});
    for (t["name"])
    {
      make Beispiel name=_.val,length=sum(length());
      out;
    }

Оператор _make_ завжди створює новий об'єкт, так званий _derived_.
Навіщо взагалі генерувати об'єкт?
Чому б просто не взяти об'єкт OpenStreetMap?
Причина цього різняться від застосунку до застосунку:
тут, нам потрібно щось що ми можемо повернути (надрукувати).
В інших випадках є потреба
змінити чи вилучити теґи у об'єктів OpenStreetMap,
або ж є потреба в спрощенні геометрії,
або ж нам потрібен спеціальний елемент для передачі особливої інформації.
Квазі об'єкти OpenStreetMap мають дотримуватись правил, що застосовуються до об'єктів OpenStreetMap 
і не дають потрібної свободи дій, потрібної в таких випадках.
Що ще важливіше, їх можна сплутати з реальними об'єктами OpenStreetMap і випадково завантажити в базу OpenStreetMap.

Ви можете подивитись на створені об'єкти, якщо ви використовуєте [XML](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=16&Q=way%5Bhighway%5D%28%7B%7Bbbox%7D%7D%29%3B%0Afor%20%28t%5B%22name%22%5D%29%0A%7B%0A%20%20make%20Beispiel%20name%3D%5F%2Eval%2Clength%3Dsum%28length%28%29%29%3B%0A%20%20out%3B%0A%7D) як вихідний формат:

    way[highway]({{bbox}});
    for (t["name"])
    {
      make Beispiel name=_.val,length=sum(length());
      out;
    }

<a name="sets"/>
## Паралельні множині запити

У багатьох випадках одного вибору недостатньо для розв'язання проблеми.
Натомість результати запитів можуть зберігатись всередині іменованих змінних
і таким чином кілька запитів можуть зберігатись паралельно.

Ми хочемо знайти всі об'єкти одного виду, які не є близькими до об'єктів іншого виду.
Практичними прикладами часто є питання забезпечення якості, напр. залізничні платформи, віддалені від залізниць, або адреси які знаходяться далеко від будь-якої вулиці.
Правила теґування виходять за межі цього розділу.

Натомість визначимо всі супермаркети
які [не знаходяться поруч](https://overpass-turbo.eu/?lat=51.4775&lon=0.0&zoom=14&Q=nwr%5Bpublic%5Ftransport%3Dstation%5D%28%7B%7Bbbox%7D%7D%29%2D%3E%2Eall%5Fstations%3B%0A%28%0A%20%20nwr%5Bshop%3Dsupermarket%5D%28%7B%7Bbbox%7D%7D%29%3B%0A%20%20%2D%20nwr%2E%5F%28around%2Eall%5Fstations%3A300%29%3B%0A%29%3B%0Aout%20center%3B) із залізничними станціями:

    nwr[public_transport=station]({{bbox}})->.all_stations;
    (
      nwr[shop=supermarket]({{bbox}});
      - nwr._(around.all_stations:300);
    );
    out center;

Вираз з рядка 3 ``nwr[shop=supermarket]({{bbox}})`` знаходить всі супермаркети на видимій частині мапи.
Нам потрібно вилучити підмножину з цього набору, тож ми використовуємо блоковий вираз типу _difference_;
він характеризується трьома компонентами: дужка ``(`` у рядку 2, знак ``-`` в рядку 4, та дужка ``)`` в рядку 5.

Нам потрібно отримати всі супермаркети поруч зі станціями.
Для цього, спочатку відшукаємо станції,
але нам також потрібні супермаркети.
Тож, ми перенаправимо результат пошуку станцій до _змінної_ ``all_stations``.
Результат рядка 1 зі звичайного виразу ``nwr[public_transport=station]({{bbox}})`` переспрямовується 
за допомогою спеціального синтаксису ``->.all_stations`` до відповідної змінної.
Доповнення ``.all_stations`` в ``(around.all_stations:300)`` каже фільтру
що потрібно використовувати змінну замість результатів останнього запиту.

Таким чином ``nwr[shop=supermarket]({{bbox}})(around.all_stations:300)`` є тим виразом,
який дозволяє нам отримати ті супермаркети які ми хочемо прибрати з набору.
Для прискорення запиту, ми скористаємось результатом, який ми отримали в рядку 3 -
у нас тут вже є всі супермаркети, що знаходяться у видимій частині мапи.
Для цього скористаємося _фільтром_ ``._``.
Він обмежує результати об'єктами,
які вже є в буфері перед початком виконання виразу.
Тому що ми використовуємо стандартний ввід,
ми можемо звертатись до нього за його назвою ``_`` (символ підкреслювання).

Потік даних під час виконання запиту в деталях:

* Перед початком виконання всі результати є порожніми.
* Виконується рядок 1.
  Завдяки ``->.all_stations``, всі знайдені станції зберігаються до змінної ``all_stations``,
  типовий буфер для збереження результатів залишається порожнім.
* Рядки 2 - 5 є блоковим виразом типу _difference_,
  і спочатку виконується ініціалізація блоку.
  Потім, опрацьовується вираз, рядок 3, ``nwr[shop=supermarket]({{bbox}})``.
  Рядок 3 не містить перенаправлення,
  тож після його виконання всі супермаркети зберігаються до типового буферу.
  Результат з ``all_stations`` не згадується, тож залишається без змін.
* Блоковий вираз _difference_ копіює результат свого першого операнду, це рядок 3.
* Рядок 4 використовує результат з типового буферу як обмеження,
  на додачу до обмеження ``(around.all_stations:300)``
  результат з ``all_stations`` використовується як джерело для пов'язаних об'єктів.
  В результаті типовий буфер результатів перезаписується відфільтрованими даними.
  Результат з ``all_stations`` залишається незмінним.
* Блоковий вираз _difference_ копіює результати другого операнда, це рядок 4.
* Блоковий вираз _difference_ тепер обраховує різницю між двома наборам.
  Через те що більше нічого не зазначено,
  результат обчислень записується в типовий буфер.
  Результат з ``all_stations`` залишається незмінним.
* І на останок, виконується рядок 5.
  Без будь-яких явних інструкцій, оператор ``out`` виводить значення типового буферу.
